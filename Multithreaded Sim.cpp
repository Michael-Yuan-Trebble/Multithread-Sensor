#include "Multithreaded Sim.h"

struct Location {
	double x, y, z;
};

enum SensorType {
	GPS,
	IMU,
	Radar
};

struct SensorReading {
	SensorType source;
	Location loc;
};

// Basic one dimensional KalmanFilter
class KalmanFilter 
{
	double estimatedPos;
	double estimatedUncert;
	double coefficient;
	double processNoise;
	double measurementNoise;
	bool isInit = false;

public:
	KalmanFilter(double inProcessNoise, double inMeasurementNoise)
		: coefficient(1.0), processNoise(inProcessNoise), measurementNoise(inMeasurementNoise), estimatedUncert(1.0), estimatedPos(0.0) {}

	void init(double initValue) 
	{
		estimatedPos = initValue;
		isInit = true;
	}

	double update(double inMeasurement)
	{
		if (!isInit) 
		{
			estimatedPos = inMeasurement;
			isInit = true;
		}

		estimatedPos = coefficient * coefficient * estimatedUncert + processNoise;

		double gain = (estimatedUncert) / (estimatedUncert + measurementNoise);

		estimatedPos += gain * (inMeasurement - estimatedPos);

		estimatedUncert = (1 - gain) * estimatedUncert;

		return estimatedPos;
	}

	double getValue() const { return estimatedPos; }
};

// The randomization seed for each thread
unsigned static SeedGenerator()
{
	static std::random_device rd;
	auto tid = std::hash<std::thread::id>{}(std::this_thread::get_id());
	return rd() ^ static_cast<unsigned>(tid);
}

// Thread Object for Combination to know what to replace
class ThreadQueue 
{
	std::queue<SensorReading> q;
	std::mutex m;
	std::condition_variable cv;
public:
	void push(const SensorReading& value) 
	{
		{
			std::lock_guard<std::mutex> lock(m);
			q.push(value);
		}
		cv.notify_one();
	}
	SensorReading pop() 
	{
		std::unique_lock<std::mutex> lock(m);
		cv.wait(lock, [this] {return !q.empty();});
		SensorReading value = q.front();
		q.pop();
		return value;
	}
};

ThreadQueue GlobalQueue;
std::chrono::steady_clock::time_point programStart;
std::ofstream myFile;
std::mutex latestM;

// Obtain the random noise generated by each sensor
static Location GetScatter(Location trueLoc, SensorType Type, std::mutex& m)
{
	int NOISE_RANDOM = 0;
	std::string sensorString = "";
	switch (Type)
	{
	case GPS:
		sensorString = "GPS";
		NOISE_RANDOM = GPS_Noise; break;
	case IMU:
		sensorString = "IMU";
		NOISE_RANDOM = IMU_Interval; break;
	case Radar:
		sensorString = "Radar";
		NOISE_RANDOM = Radar_Interval; break;
	}
	thread_local static std::mt19937 gen(SeedGenerator());

	std::normal_distribution<> noise(0.0, NOISE_RANDOM);

	Location noiseLocation{
		trueLoc.x + noise(gen),
		trueLoc.y + noise(gen),
		trueLoc.z + noise(gen)
	};

	{
		std::lock_guard<std::mutex> lock(m);
		auto now = std::chrono::steady_clock::now();
		auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - programStart).count();

		myFile << elapsed << "," << sensorString << ","
			<< noiseLocation.x << "," << noiseLocation.y << "," << noiseLocation.z << std::endl;
	}
	return noiseLocation;
}

// Creates a thread with varying time intervals
static void TypeThread(Location trueLoc, SensorType type, std::mutex& m) 
{
	int timeInterval = 0;
	switch (type)
	{
	case GPS:
		timeInterval = GPS_Interval; break;
	case IMU:
		timeInterval = IMU_Interval; break;
	case Radar:
		timeInterval = Radar_Interval; break;
	}

	while(true) 
	{
		SensorReading SensorIn{};
		SensorIn.loc = GetScatter(trueLoc, type,m);
		SensorIn.source = type;
		{
			std::lock_guard<std::mutex> lock(m);
			GlobalQueue.push(SensorIn);
		}
		std::this_thread::sleep_for(std::chrono::seconds(timeInterval));
	}
}

std::optional<Location> LatestGPS;
std::optional<Location> LatestRadar;
std::optional<Location> LatestIMU;

// Combine all of the different sensors into one location
static void Combine(std::mutex& m) 
{

	KalmanFilter kfX(0.1, 2.0);
	KalmanFilter kfY(0.1, 2.0);
	KalmanFilter kfZ(0.1, 2.0);

	while (true) 
	{
		SensorReading Reading = GlobalQueue.pop();
			switch (Reading.source) 
			{
			case SensorType::GPS:
				LatestGPS = Reading.loc; break;
			case SensorType::Radar:
				LatestRadar = Reading.loc; break;
			case SensorType::IMU:
				LatestIMU = Reading.loc; break;
			}
			if (LatestGPS && LatestRadar && LatestIMU)
			{
				double measuredX = (LatestGPS->x + LatestRadar->x + LatestIMU->x) / 3.0;
				double measuredY = (LatestGPS->y + LatestRadar->y + LatestIMU->y) / 3.0;
				double measuredZ = (LatestGPS->z + LatestRadar->z + LatestIMU->z) / 3.0;

				double filteredX = kfX.update(measuredX);
				double filteredY = kfY.update(measuredY);
				double filteredZ = kfZ.update(measuredZ);

				Location Combined{ filteredX, filteredY, filteredZ };

				{
					std::lock_guard<std::mutex> lock(m);
					auto now = std::chrono::steady_clock::now();
					auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - programStart).count();
					myFile << elapsed << "," << "Filtered" << ","
						<< Combined.x << "," << Combined.y << "," << Combined.z << std::endl;
				}
			}
	}
}

// Create all threads
static void CreateThreads(Location InLoc) 
{
	std::thread GPSThread(TypeThread, InLoc, GPS, std::ref(latestM));
	GPSThread.detach();
	std::thread IMUThread(TypeThread, InLoc, IMU, std::ref(latestM));
	IMUThread.detach();
	std::thread RadarThread(TypeThread, InLoc, Radar, std::ref(latestM));
	RadarThread.detach();

	std::thread CombineThread(Combine, std::ref(latestM));
	CombineThread.detach();
}

int main()
{
	programStart = std::chrono::steady_clock::now();
	myFile.open("data.csv", std::ios::out | std::ios::trunc);

	myFile << "time,sensor type,x,y,z" << std::endl;
	
	QFile file("./Location.json");
	if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) 
	{
		qWarning() << "Could not open file!";
		return -1;
	}

	QByteArray fileData = file.readAll();
	file.close();

	QJsonDocument doc = QJsonDocument::fromJson(fileData);
	if (!doc.isObject())
	{
		qWarning() << "Expected a JSON object!";
		return -1;
	}

	QJsonObject obj = doc.object();
	double x = obj["x"].toDouble();
	double y = obj["y"].toDouble();
	double z = obj["z"].toDouble();
	GPS_Noise = obj["GPS_Noise"].toDouble();
	IMU_Noise = obj["IMU_Noise"].toDouble();
	Radar_Noise = obj["Radar_Noise"].toDouble();
	GPS_Interval = obj["GPS_Interval"].toDouble();
	IMU_Interval = obj["IMU_Interval"].toDouble();
	Radar_Interval = obj["Radar_Interval"].toDouble();

	Location InLoc = Location({x,y,z});
	CreateThreads(InLoc);
	std::cin.get();
	std::cout << "Exiting Program...";
	return 0;
}