#include "Multithreaded Sim.h"

struct Location {
	double x, y, z;
};

enum SensorType {
	GPS,
	IMU,
	Radar
};

struct SensorReading {
	SensorType source;
	Location loc;
};

inline unsigned SeedGenerator()
{
	static std::random_device rd;
	auto tid = std::hash<std::thread::id>{}(std::this_thread::get_id());
	return rd() ^ static_cast<unsigned>(tid);
}

// Thread Object for Combination to know what to replace
class ThreadQueue 
{
	std::queue<SensorReading> q;
	std::mutex m;
	std::condition_variable cv;
public:
	void push(const SensorReading& value) 
	{
		{
			std::lock_guard<std::mutex> lock(m);
			q.push(value);
		}
		cv.notify_one();
	}
	SensorReading pop() 
	{
		std::unique_lock<std::mutex> lock(m);
		cv.wait(lock, [this] {return !q.empty();});
		SensorReading value = q.front();
		q.pop();
		return value;
	}
};

ThreadQueue GlobalQueue;
std::chrono::steady_clock::time_point programStart;
std::ofstream myFile;
std::mutex latestM;

// Obtain the random noise generated by each sensor
static Location GetScatter(Location trueLoc, SensorType Type, std::mutex& m)
{
	int NOISE_RANDOM = 0;
	std::string sensorString = "";
	switch (Type)
	{
	case GPS:
		sensorString = "GPS";
		NOISE_RANDOM = 10; break;
	case IMU:
		sensorString = "IMU";
		NOISE_RANDOM = 15; break;
	case Radar:
		sensorString = "Radar";
		NOISE_RANDOM = 20; break;
	}
	thread_local static std::mt19937 gen(SeedGenerator());

	std::normal_distribution<> noise(0.0, NOISE_RANDOM);

	Location noiseLocation{
		trueLoc.x + noise(gen),
		trueLoc.y + noise(gen),
		trueLoc.z + noise(gen)
	};

	{
		std::lock_guard<std::mutex> lock(m);
		auto now = std::chrono::steady_clock::now();
		auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - programStart).count();

		myFile << elapsed << "," << sensorString << ","
			<< noiseLocation.x << "," << noiseLocation.y << "," << noiseLocation.z << std::endl;

		std::cout << sensorString << ": "
			<< noiseLocation.x << "," << noiseLocation.y << "," << noiseLocation.z
			<< std::endl;
	}
	return noiseLocation;
}

// Creates a thread with varying time intervals
static void TypeThread(Location trueLoc, SensorType type, std::mutex& m) 
{
	int timeInterval = 0;
	switch (type)
	{
	case GPS:
		timeInterval = 5; break;
	case IMU:
		timeInterval = 10; break;
	case Radar:
		timeInterval = 15; break;
	}

	while(true) 
	{
		SensorReading SensorIn{};
		SensorIn.loc = GetScatter(trueLoc, type,m);
		SensorIn.source = type;
		{
			std::lock_guard<std::mutex> lock(m);
			GlobalQueue.push(SensorIn);
		}
		std::this_thread::sleep_for(std::chrono::seconds(timeInterval));
	}
}

std::optional<Location> LatestGPS;
std::optional<Location> LatestRadar;
std::optional<Location> LatestIMU;

// Combine all of the different sensors into one location
static void Combine(std::mutex& m) 
{
	while (true) 
	{
		SensorReading Reading = GlobalQueue.pop();
			switch (Reading.source) 
			{
			case SensorType::GPS:
				LatestGPS = Reading.loc; break;
			case SensorType::Radar:
				LatestRadar = Reading.loc; break;
			case SensorType::IMU:
				LatestIMU = Reading.loc; break;
			}
			if (LatestGPS && LatestRadar && LatestIMU) 
			{
				Location Combined = Location({
					(LatestGPS->x + LatestRadar->x + LatestIMU->x) / 3.0,
					(LatestGPS->y + LatestRadar->y + LatestIMU->y) / 3.0,
					(LatestGPS->z + LatestRadar->z + LatestIMU->z) / 3.0
										});
				{
					std::lock_guard<std::mutex> lock(m);
					auto now = std::chrono::steady_clock::now();
					auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - programStart).count();
					myFile << elapsed << "," << "Combined" << "," << Combined.x << "," << Combined.y << "," << Combined.z << std::endl;
				}
			}
	}
}

// Create all threads
static void CreateThreads(Location InLoc) 
{
	std::thread GPSThread(TypeThread, InLoc, GPS, std::ref(latestM));
	GPSThread.detach();
	std::thread IMUThread(TypeThread, InLoc, IMU, std::ref(latestM));
	IMUThread.detach();
	std::thread RadarThread(TypeThread, InLoc, Radar, std::ref(latestM));
	RadarThread.detach();

	std::thread CombineThread(Combine, std::ref(latestM));
	CombineThread.detach();
}

int main()
{
	programStart = std::chrono::steady_clock::now();
	myFile.open("data.csv", std::ios::out | std::ios::app);

	myFile << "time,sensor type,x,y,z" << std::endl;
	
	Location InLoc = Location({ 1,1,1 });
	CreateThreads(InLoc);
	std::cin.get();
	std::cout << "Exiting Program...";
	return 0;
}